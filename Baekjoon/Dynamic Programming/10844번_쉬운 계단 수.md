## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 풀이
1. 마지막 자리의 수가 0이나 9인 경우를 제외하고 이전 DP 배열에서의 앞과 뒤의 경우의 수를 가져올 수 있다.
2. 이런 경우에 앞과 뒤의 경우의 수를 더한 값을 현재 DP의 경우의 수로 설정한다.
3. 마지막 자리의 수가 0인 경우에는 이전 숫자가 1인 경우의 경우의 수를 그대로 가져오고, 9인 경우에는 이전 숫자가 8인 경우의 경우의 수를 그대로 가져온다.
4. 마지막에 모든 마지막 자리의 수들의 경우의 수를 더하고 출력한다.

```cpp
#include <iostream>
#define mod 1000000000

using namespace std;

int main(void) {
	int N;
	cin >> N;

	// 2차원 DP 배열 생성
	int DP[101][10] = {};

	for (int i = 0; i < 10; i++) {
		DP[1][i] = 1;
	}

	// 길이가 증가한 경우 마지막 숫자가 0, 9 일 경우를 제외하고 이전 배열에서의 앞, 뒤 숫자 덧셈
	for (int i = 2; i <= N; i++) {
		for (int j = 0; j < 10; j++) {
			if (j == 0) {
				DP[i][0] = DP[i - 1][1];
			}
				
			else if (j == 9) {
				DP[i][9] = DP[i - 1][8];
			}
				
			else {
				DP[i][j] = (DP[i - 1][j - 1] + DP[i - 1][j + 1]) % mod;
			}	
		}
	}

	int sum = 0;

	// 모든 경우의 수 더하기
	for (int i = 1; i < 10; i++) {
		sum = (sum + DP[N][i]) % mod;
	}

	cout << sum % mod;

	return 0;
}
```
