## 문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

## 출력
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 풀이
1. 2중 반복문을 통해 j에서 i까지 증가하는 부분수열 길이의 최댓값을 구한다.
2. 2중 반복문을 통해 i에서 j까지 감소하는 부분수열 길이의 최댓값을 구한다.
3. 같은 index의 증가수열 배열, 감소수열 배열의 원소를 더한 최댓값을 구한다.

```cpp
#include <iostream>

using namespace std;

// 증가, 감소 dp 배열
int inc[1001], des[1001];
// 수열
int S[1001];

int main() {
    // 입력
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> S[i];
    }

    // 최대 길이의 증가 부분 수열
    for (int i = 0; i < n; i++) {
        for (int j = i - 1; j >= 0; j--) {
            if (S[j] < S[i] && inc[i] < inc[j] + 1) {
                inc[i] = inc[j] + 1;
            }
        }
    }
    // 최대 길이의 감소 부분 수열
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            if (S[j] < S[i] && des[i] < des[j] + 1) {
                des[i] = des[j] + 1;
            }
        }
    }

    // 최댓값
    int result = 0;
    for (int i = 0; i < n; i++) {
        result = max(result, inc[i] + des[i]);
    }
    cout << result + 1;

    return 0;
}
```
