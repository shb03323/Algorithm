## 문제
스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.

![image](https://user-images.githubusercontent.com/39729721/123434317-4ecb6600-d607-11eb-8388-3b11f8998a53.png)

1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.
```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```
지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다.

![image](https://user-images.githubusercontent.com/39729721/123434425-6dc9f800-d607-11eb-8724-92286d0c5bdb.png)

CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.
```
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5
```
위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.

![image](https://user-images.githubusercontent.com/39729721/123434569-981bb580-d607-11eb-8308-81e2951a8fb1.png)

CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.
```
0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
```
위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.
```
# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
```
사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. 

CCTV의 최대 개수는 8개를 넘지 않는다.

## 출력
첫째 줄에 사각 지대의 최소 크기를 출력한다.

## 풀이

```java
import java.io.*;
import java.util.*;

public class Main {
    public static int n,m;
    //map : 사무실 정보
    public static int[][] map;
    //cctv의 정보들을 저장한 List
    public static List<CCTV> cctvList = new LinkedList<>();
    //count : cctv가 볼 수 있는 공간의 개수
    public static int count = 0;
    //cctv 회전 방향
    public static int[] dx = {0, 1, 0, -1};
    public static int[] dy = {-1, 0, 1, 0};

    //CCTV : cctv의 위치와 종류를 저장
    public static class CCTV {
        int row;
        int col;
        int kinds;
        public CCTV(int row, int col, int kinds) {
            this.row = row;
            this.col = col;
            this.kinds = kinds;
        }
    }

    public static void findBlindSpot(int cctvCanSee, int listIndex, int[][] testMap) {
        if(listIndex == cctvList.size()) {
            count = Math.max(count, cctvCanSee);
            return;
        }

        int kinds = cctvList.get(listIndex).kinds;

        for(int i = 0; i < 4; i++) {
            int watch = 0;
            switch(kinds) {
                case 1:
                    while(true) {
                        watch++;
                        int nx = watch * dx[i] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    findBlindSpot(watch + cctvCanSee, listIndex + 1, testMap);
                    break;

                case 2:
                    if(i >= 2) {
                        return;
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[i] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[i + 2] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i + 2] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    findBlindSpot(watch + cctvCanSee, listIndex + 1, testMap);
                    break;

                case 3:
                    while(true) {
                        watch++;
                        int nx = watch * dx[i] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 1) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 1) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    findBlindSpot(watch + cctvCanSee, listIndex + 1, testMap);
                    break;

                case 4:
                    while(true) {
                        watch++;
                        int nx = watch * dx[i] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 1) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 1) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 2) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 2) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    findBlindSpot(watch + cctvCanSee, listIndex + 1, testMap);
                    break;

                case 5:
                    if(i >= 1) {
                        return;
                    }
                    while(true) {
                        watch++;
                        int nx = watch * dx[i] + cctvList.get(listIndex).row;
                        int ny = watch * dy[i] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 1) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 1) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 2) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 2) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    while(true) {
                        watch++;
                        int nx = watch * dx[(i + 3) % 4] + cctvList.get(listIndex).row;
                        int ny = watch * dy[(i + 3) % 4] + cctvList.get(listIndex).col;

                        if(nx < 0 || nx >= n || ny < 0 || ny >= m) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] == 6) {
                            watch--;
                            break;
                        }
                        if(testMap[nx][ny] >= 1 || testMap[nx][ny] <= 5) {
                            watch--;
                            testMap[nx][ny] = 1;
                            continue;
                        }
                    }

                    findBlindSpot(watch + cctvCanSee, listIndex + 1, testMap);
                    break;
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        //n, m 입력
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        //size : 공간의 개수
        int size = n * m;
        //사무실 정보 입력
        map = new int[n][m];
        for(int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j < m; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
                //cctv가 있으면 cctv를 cctvList에 저장
                if(map[i][j] != 0) {
                    //벽이 있으면 공간 개수에서 차감
                    if(map[i][j] == 6) {
                        size--;
                    }
                    else {
                        cctvList.add(new CCTV(i, j, map[i][j]));
                    }
                }
            }
        }

        //사무실 정보 복사
        int[][] testMap = map;

        findBlindSpot(0, 0, testMap);

        System.out.println(size - count - cctvList.size());
    }
}
```
